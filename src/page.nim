import std/[
  strformat,
  os,
  strutils
]

import pkg/[
  Noise,
  nargparse
]

import
  general,
  pgenv,
  lexer,
  parser,
  state,
  interpreter,
  logging

from builtins import langVersion


template q1(v: varargs[untyped]) =
  stderr.writeLine v
  quit 1

proc repl(exe: string, args: seq[string]) =
  if not pgReplHistory.fileExists():
    pgReplHistory.writeFile("")

  var hf: File = nil

  if not open(hf, pgReplHistory, fmReadWriteExisting):
    q1 "Cannot open ", pgReplHistory

  defer:
    hf.close()

  var noise = Noise.init()

  for line in hf.readAll().split("\n"):
    noise.historyAdd(line)

  hf.setFilePos(hf.getFileSize(), fspSet)
  
  echo "Page ", langVersion, " REPL; type 'quit' to exit"

  let
    basePrompt = "PG > "
    i = newInterpreter()

  i.state.g = newGlobalState(exe, "repl", args)

  noise.setPrompt(basePrompt)

  while true:
    let stackLen = i.state.stack.len

    if stackLen > 0:
      noise.setPrompt(fmt"PG <{stackLen}> ")
    else:
      noise.setPrompt(basePrompt)

    let ok = noise.readLine()
    if not ok:
      break

    let line = noise.getLine()

    hf.writeLine(line)
    noise.historyAdd(line)

    try:
      let
        l = newLexer("repl", line)
        p = newParser(l.lex())

      i.exec(p.parse())
    except PgQuitError as e:
      quit e.code
    except PgError as e:
      echo e
    finally:
      try:
        i.runDeferred()
      except PgQuitError as e:
        quit e.code
      except PgError as e:
        echo e

proc main(args: seq[string]) =
  let argp = newArgparser("page")

  let fHelp = argp.flag("h", "help", help="Prints the help message.")
  let fVersion = argp.flag("v", "version", help="Prints the language version and exits.")
  let fRepl = argp.flag("repl", help="Runs the Page REPL.")
  let fExec = argp.opt("e", "exec", help="Executes the given Page snippet.")
  let fTokens = argp.flag("t", "tokens", help="Prints the tokens generated by the lexer.")
  let fNodes = argp.flag("n", "nodes", help="Prints the nodes generated by the parser.")
  let fLogLevel = argp.opt("log", help="Sets the log level; debug messages are NOT guaranteed to be the same between versions.")
  let fForceStd = argp.flag("fstd", "force-std", help="Force the standard library to be written; this is normally skipped after the first time Page is run.")

  let leftover =
    try:
      argp.parse(args)
    except ArgparseError as e:
      echo e.msg
      q1 argp

  if fLogLevel.exists:
    try:
      let ll = parseUInt(fLogLevel.value)
      if ll > 255:
        raise newException(ValueError, "")

      startGlobalLogger(stdout, uint8(ll))
      logger.log(fmt"Started global logger with level {logger.level}")
    except ValueError:
      q1 fmt"'{fLogLevel.value}' is not a valid log level"
  else:
    startGlobalLogger(stdout, 0)

  if fHelp.exists:
    echo argp
    return

  if fVersion.exists:
    echo "Page interpreter version ", langVersion
    return

  verifyPg()

  writeStdlib(fForceStd.exists)

  if fExec.exists:
    var tokens: seq[Token]
    let l = newLexer("exec", fExec.value)
    try:
      tokens = l.lex()
    except PgError as e:
      q1 e

    var nodes: seq[Node]
    let p = newParser(tokens)
    try:
      nodes = p.parse()
    except PgError as e:
      q1 e

    let i = newInterpreter()

    i.state.g = newGlobalState(getAppFilename(), "exec", leftover[1..^1])

    try:
      i.exec(nodes)
    except PgQuitError as e:
      quit e.code
    except PgError as e:
      q1 e

    return

  if fRepl.exists:
    repl(getAppFilename(), leftover)
    return

  if leftover.len() == 0:
    q1 "No input files"

  let
    l = newLexer(leftover[0], readFile(leftover[0]))
    
    tokens =
      try:
        l.lex()
      except PgError as e:
        q1 e

  if fTokens.exists:
    for t in tokens:
      echo t

  let
    p = newParser(tokens)
    
    nodes =
      try:
        p.parse()
      except PgError as e:
        q1 e

  if fNodes.exists:
    for n in nodes:
      echo n

  let i = newInterpreter()

  i.state.g = newGlobalState(getAppFilename(), leftover[0].absolutePath(), leftover[1..^1])

  try:
    i.exec(nodes)
  except PgQuitError as e:
    quit e.code
  except PgError as e:
    q1 e


when isMainModule:
  main(commandLineParams())
